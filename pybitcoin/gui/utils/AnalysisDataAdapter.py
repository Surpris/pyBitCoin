#! /usr/bin/python3
# -*- coding: utf-8 -*-

import copy
import datetime
import numpy as np
import pandas as pd
import pickle

from .footprint import footprint
from .mathfunctions import dataset_for_boxplot

class AnalysisDataAdapter(object):
    """AnalysisDataAdapter(object)
    
    This class offers an adapter of results of analysis used in pybitcoin.
    """

    def __init__(self, results=None, dataset=None, N_ema_min=10, N_ema_max=30):
        """__init__(self, results=None, dataset=None, N_ema_min=10, N_ema_max=30) -> None
        
        initialize this class

        Parameters
        ----------
        results   : dict (default : None)
            results of analysis
        dataset   : dict (default : None)
            dataset generated by a DataAapter instance
        N_ema_min : int (default : 10)
            the minimum of N number for EMA lines
        N_ema_max : int (default : 30)
            the maximum of N number for EMA lines
        """
        self._analysis_results = results
        self._dataset = dataset
        self.N_ema_min = N_ema_min
        self.N_ema_max = N_ema_max
        self._initialized = False
        self.initInnerData()
    
    @footprint
    def initInnerData(self):
        """initInnerData(self) -> None

        initialize the inner data according to analysis results
        """
        try:
            if self._analysis_results is None and not self._initialized:
                self._benefit_map = np.zeros((self.N_ema_max + 1, self.N_ema_max + 1), dtype=int)
                self._stat_dead_list = []
                self._stat_golden_list = []
                self._dec_dead_box_list = []
                self._dec_golden_box_list = []
                self._dec_dead_list = []
                self._dec_golden_list = []
            elif isinstance(self._analysis_results, dict):
                buff = np.zeros((self.N_ema_max + 1, self.N_ema_max + 1), dtype=int)
                self._benefit_map = self._analysis_results.get("benefit_map", buff)
                self._stat_dead_list = self._analysis_results.get("stat_dead_list", [])
                self._stat_golden_list = self._analysis_results.get("stat_golden_list", [])
                self._dec_dead_box_list = self._analysis_results.get("dec_dead_box_list", [])
                self._dec_golden_box_list = self._analysis_results.get("dec_golden_box_list", [])
                self._dec_dead_list = self._analysis_results.get("dec_dead_list", [])
                self._dec_golden_list = self._analysis_results.get("dec_golden_list", [])
            elif not self._initialized:
                raise TypeError('analysis_results must be a dict object.')
            self._initialized = True
        except Exception as ex:
            print(ex)
    
    @footprint
    def updateInnerDataByDataset(self):
        """updateInnerDataByDataset(self) -> None

        update the inner data according to the dataset
        """
        try:
            if self._dataset is None:
                raise ValueError("`dataset` is not a dict object.")
            elif isinstance(self._analysis_results, dict):
                self._benefit_map = np.zeros((self.N_ema_max + 1, self.N_ema_max + 1), dtype=int)
                self._stat_dead_list = []
                self._stat_golden_list = []
                self._dec_dead_box_list = []
                self._dec_golden_box_list = []
                self._dec_dead_list = []
                self._dec_golden_list = []

                # calculate statistics and benefits for each pair (N_ema1, N_ema2)
                for ii in range(self.N_ema_min, self.N_ema_max):
                    # calculate a dataset of signals
                    N_ema1 = ii
                    N_ema2 = ii + 1
                    # TODO: implement
            else:
                raise TypeError('`dataset` is not a dict object.')
            self._initialized = True
        except Exception as ex:
            print(ex)
        
    @property
    def analysis_results(self):
        return self._analysis_results
    
    @analysis_results.setter
    def analysis_results(self, v):
        self._analysis_results = copy.deepcopy(v)
        self.initInnerData()

    @property
    def dataset(self):
        return self._dataset
    
    @dataset.setter
    def dataset(self, v):
        self._dataset = copy.deepcopy(v)